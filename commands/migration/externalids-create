#!/usr/bin/env bash

# Create external IDs for DTM assets based on template with parallel processing

# Stop on unexpected errors
set -e

# Logging helper functions (output to stderr)
warn() { echo -e "\033[1;33mWARN  $*\033[0m" >&2; }
# error <colored-part> <plain-part>
error() {
    local colored_part="$1"
    local plain_part="$2"
    echo -e "\033[1;31mERROR $colored_part\033[0m $plain_part" >&2
}
info() { echo -e "INFO  $*" >&2; }
success() { echo -e "\033[1;32mSUCCESS $*\033[0m" >&2; }

# Help text
help() {
    cat <<EOF
Create external IDs for DTM assets to be used with upserting assets.

Usage:
    c8y dtm migration externalids-create [FLAGS]

Description:
    This command creates external IDs for DTM assets using a configurable template.
    All assets or all assets matching a given query will be updated with a
    c8y_ExternalId fragment generated based on the provided template. The template
    can include placeholders for any asset fragment or property. 
    
    For the c8y_ExternalId, an external id of type c8y_Asset will be created in the
    Identity API.

    Using the --external-asset flag, a c8y_ExternalAsset fragment can also be added
    to the asset with an optional JSON object as its value. If no value is provided,
    the fragment will be created with an empty object. If null is provided, the fragment
    will be deleted.

Flags:
    -t, --id-template <template> Template for generating the value of c8y_ExternalId assigned to the asset (required)
                                 Supports placeholders for any asset fragment or property
    -e, --external-asset <json>  Assign c8y_ExternalAsset using an optional JSON object as its value.)
    -u, --use-asset-upsert       Use asset upsert (c8y dtm assets update) for external ID creation (default: false)
    -l, --logDir <directory>     Directory for log files (default: current directory)
    -f, --filter <query>         Query to filter assets (e.g., "type eq 'MyAssetType'", default: "not(has(${EXTERNAL_ID_FRAGMENT}))")
    -h, --help                   Show this help message
        --examples               Show usage examples

Template Placeholders:
    {<fragment>}               Any fragment (e.g., {name} or {id})
    {<fragment>.<property>}    Any fragment property (e.g., {c8y_IsDevice.name})
    
    Note: Template placeholders can reference any fragment or property available
    in the asset's JSON structure. Use dot notation for nested properties.

Requirements:
    - go-c8y-cli authenticated session (dev mode)
    - jq for JSON processing

EOF

exit 0
}

examples () {
  cat <<EOF
Examples:
    # Create external IDs with simple ID template
    c8y dtm migration externalids-create --id-template "dtm_{id}" --external-asset '{"source": "Acme Inc."}'
    
    # Use asset name and type fragments
    c8y dtm migration externalids-create --id-template "asset_{name}_{type}" --workers 8

    # Complex template with multiple fragments
    c8y dtm migration externalids-create --id-template "{owner}_{fragment.name}_{id}"

    # Use external asset JSON data
    c8y dtm migration externalids-create --id-template "ext_{id}" --external-asset '{"source": "Acme Inc."}'

    # Check assets have properties used in template and no external IDs yet
    c8y inventory find --fragmentType "c8y_IsAsset" --select id,name,fragment1,fragment2,c8y_ExternalId --pageSize 1

    # Check relevant fragments after creation
    c8y inventory find --query "has(c8y_ExternalId)" --fragmentType "c8y_IsAsset" --select id,c8y_ExternalId,c8y_ExternalAsset
    
    # Check identity has been created correctly
    c8y inventory find --fragmentType "c8y_IsAsset" --pageSize 1 | c8y identity list --filter 'type eq c8y_Asset' 

EOF

exit 0
}

# Default values
EXTERNAL_ID_FRAGMENT="c8y_ExternalId"
EXTERNAL_ASSET_FRAGMENT="c8y_ExternalAsset"

ID_TEMPLATE=""
EXTERNAL_ASSET=""
FILTER_QUERY="not(has(${EXTERNAL_ID_FRAGMENT}))"
USE_ASSET_UPSERT=0
LOG_DIR="."
POSITIONAL_ARGS=()

# Parse Flags: --flag <value>, or boolean/switch flags: --help|-h
while [ $# -gt 0 ]; do
    case "$1" in
        # Flag which expects an argument
        -t|--id-template)
            if [ -z "$2" ] || [[ "$2" =~ ^- ]]; then
                error "--id-template requires a template string argument." "Use --help for details."
                exit 1
            fi
            ID_TEMPLATE="$2"
            shift
            ;;
        -e|--external-asset)
            if [ -z "$2" ] || [[ "$2" =~ ^- ]]; then
                EXTERNAL_ASSET="{}"
            else
                EXTERNAL_ASSET="$2"
                shift
            fi
            ;;
        -f|--filter)
            if [[ "$2" =~ ^- ]]; then
                error "--filter requires a query string argument." "Use --filter \"\" to query without any filter."
                exit 1
            fi
            FILTER_QUERY="$2"
            shift
            ;;
        -l|--logDir)
            LOG_DIR="$2"
            shift
            ;;
        -u|--use-asset-upsert)
            USE_ASSET_UPSERT=1
            ;;
        # Support showing help
        -h|--help)
            help
            ;;
        --examples)
            examples
            ;;
        # Save positional arguments
        *)
            POSITIONAL_ARGS+=("$1")
            ;;
    esac
    shift
done

# Ensure log directory exists
if [ ! -d "$LOG_DIR" ]; then
    mkdir -p "$LOG_DIR"
fi

JSON_MAP="$LOG_DIR/dtm-create-externalid-asset-map.json"

# Restore additional arguments
set -- "${POSITIONAL_ARGS[@]}"

# List of allowed global/inherited flags for c8y identity/inventory calls (short and long forms)
ALLOWED_FLAGS=(
  --debug --delay --delayBefore --header -k --insecure -l --logMessage --maxJobs --noAccept -M --noColor --noCache --progress --timeout --totalErrors --workers --verbose
)

# Parse positional args for allowed global flags
C8Y_FLAGS=()
IDX=0
while [ $IDX -lt ${#POSITIONAL_ARGS[@]} ]; do
    arg="${POSITIONAL_ARGS[$IDX]}"
    if [ -z "$arg" ]; then
        IDX=$((IDX+1))
        continue
    fi
    found=0
    for flag in "${ALLOWED_FLAGS[@]}"; do
        if [ "$arg" = "$flag" ]; then
            found=1
            C8Y_FLAGS+=("$arg")
            # If next arg is not another flag, treat as value
            next_idx=$((IDX+1))
            next_arg="${POSITIONAL_ARGS[$next_idx]:-}"
            if [[ ! "$next_arg" =~ ^- ]]; then
                C8Y_FLAGS+=("$next_arg")
                IDX=$((IDX+1))
            fi
            break
        fi
    done
    if [ $found -eq 0 ]; then
        error "Unknown or unsupported flag: $arg"
        exit 1
    fi
    IDX=$((IDX+1))
done

# Function to check prerequisites
check_prerequisites() {
    if ! command -v c8y >/dev/null 2>&1; then
        error "go-c8y-cli (c8y) is not installed or not in PATH"
        exit 1
    fi

    if ! command -v jq >/dev/null 2>&1; then
        error "jq is not installed or not in PATH. Please install jq for JSON processing"
        exit 1
    fi

    # Check if authenticated
    if ! c8y currentuser get >/dev/null 2>&1; then
        error "Not authenticated with Cumulocity. Please run 'set-session' first"
        exit 1
    fi
}

# Function to generate external ID from template
generate_external_id() {
    local asset_json="$1"
    local template="$2"
    local result="$template"
    local placeholders
    # Use TEMPLATE_PROPERTIES instead of extracting placeholders again
    for property_path in "${TEMPLATE_PROPERTIES[@]}"; do
        local placeholder="{$property_path}"
        jq_filter=".$property_path"

        local value=""
        # Prefer raw string values; otherwise stringify the JSON value
        value=$(echo "$asset_json" | jq -r "if ($jq_filter | type) == \"string\" then $jq_filter else ($jq_filter | tostring) end" 2>/dev/null || echo "")
        if [ "$value" = "null" ] || [ -z "$value" ]; then
            error "Missing value for property path '$property_path'"
            return 1
        fi
        result="${result//$placeholder/$value}"
    done
    echo "$result"
}

# Function to extract template properties
extract_template_properties() {
    local template="$1"
    local properties=()
    local placeholders
    placeholders=$(echo "$template" | grep -oE '\{[^}]+\}' | sort -u)
    while IFS= read -r placeholder; do
        if [ -n "$placeholder" ]; then
            # remove curly braces from placeholder
            local property_path="${placeholder//[\{\}]/}"
            properties+=("$property_path")
        fi
    done <<< "$placeholders"
    echo "${properties[@]}"
}

join() {
  local IFS="$1"
  shift
  echo "$*"
}

## Validate arguments

# Check if ID template is provided
if [ -z "$ID_TEMPLATE" ]; then
    error "ID template is required. Use --id-template option" "See 'c8y dtm migration externalids-create --help' for details."
    exit 1
fi

# Validate external asset JSON format
if [ -z "$EXTERNAL_ASSET" ] || ! echo "$EXTERNAL_ASSET" | jq empty; then
    error "Invalid JSON for --external-asset: $EXTERNAL_ASSET" "Use '{\"source\": \"Acme Inc.\"}' or similar."
    exit 1
fi

# Check prerequisites
check_prerequisites

# Extract properties from template
TEMPLATE_PROPERTIES=()
while IFS= read -r prop; do
    TEMPLATE_PROPERTIES+=("$prop")
done < <(extract_template_properties "$ID_TEMPLATE")

# Function to read assets with pagination and generate JSON lines (NDJSON)
read_assets() {
    # Initialize intermediate JSON file (clear it)
    true > "$JSON_MAP"

    local start_time end_time elapsed
    start_time=$(date +%s)

    local select_fields=("id" "self")
    # Add template properties to select_fields (only unique ones)
    for prop in "${TEMPLATE_PROPERTIES[@]}"; do
        if [[ ! " ${select_fields[*]} " == *" ${prop} "* ]]; then
            select_fields+=("$prop")
        fi
    done

    jq_external_id=$(echo "$ID_TEMPLATE" | sed -E 's/\{([a-zA-Z0-9_.]+)\}/\\(.\1)/g')
    jq_filter="{ $(join_jq_with_error_check "${select_fields[@]}"), external_id:\"$jq_external_id\", tenant: \"$C8Y_TENANT\" }"

    local c8y_args=(inventory find 
        --includeAll 
        --fragmentType "c8y_IsAsset" 
        --select "$(join ',' "${select_fields[@]}")"
        --output json
    )
    if [ -n "$FILTER_QUERY" ]; then
        c8y_args+=(--query "$FILTER_QUERY")
    fi
    page_result=$(c8y "${c8y_args[@]}" 2>/dev/null)

    if [ -z "$page_result" ] || [ "$page_result" = "null" ] || [ "$page_result" = "[]" ]; then
        info "No assets found matching query '$FILTER_QUERY'. Use --filter to specify a different query."
        return 0
    fi

    echo "$page_result" | jq -c "$jq_filter" >> "$JSON_MAP"

    assets_with_errors=$(jq -c 'select(.error == "MissingRequiredField")' "$JSON_MAP" | grep -v '^[[:space:]]*$' )
    error_count=$(echo "$assets_with_errors" | wc -l | tr -d ' \n\r\t')
    if [ "$error_count" -gt 0 ]; then
        echo "$assets_with_errors"
        error "Found $error_count assets with missing required fields for generating external IDs:"
        exit 1
    fi

    duplicates=$(jq -r '.external_id' "$JSON_MAP" | sort | uniq -d)
    if [ -n "$duplicates" ]; then
        echo "$duplicates"
        error "Found duplicate generated external IDs. Can not create unique external IDs with the provided template."
        exit 1
    fi

    local total_collected
    total_collected=$(wc -l < "$JSON_MAP" | tr -d ' \n\r\t')
    end_time=$(date +%s)
    elapsed=$((end_time - start_time))
    success "Collected $total_collected assets for $C8Y_TENANT (${elapsed}s)"

    return 0
}

# Function to process assets with pagination
process_assets() {
    local total_processed=0
    local total_failed=0

    local start_time end_time elapsed
    start_time=$(date +%s)

    # Create output template for assets. This is used to capture the output of the c8y commands.
    # We include id, type, c8y_ExternalId, tenant, self, and all template properties.
    # tenant and self is added to help with debugging and tracking when running across multiple tenants.
    output_template_fields=(
        "id: if std.objectHas(output, 'id') then output.id else input.value.id"
        "type: if std.objectHas(output, 'type') then output.type else std.get(input.value, 'type', null)"
        "c8y_ExternalId: if std.objectHas(output, 'c8y_ExternalId') then output.c8y_ExternalId else std.get(input.value, 'c8y_ExternalId', null)"
        "c8y_ExternalAsset: if std.objectHas(output, 'c8y_ExternalAsset') then output.c8y_ExternalAsset else null"
        "['self']: if std.objectHas(output, 'self') then output['self'] else input.value['self']"
        "tenant: \"$C8Y_TENANT\""
    )
    # Add template properties, skipping duplicates and 'self'
    for prop in "${TEMPLATE_PROPERTIES[@]}"; do
        [[ "$prop" == "id" || "$prop" == "c8y_ExternalId" || "$prop" == "self" ]] && continue
        if [[ "$prop" =~ ^[a-zA-Z_][a-zA-Z0-9_]*$ ]]; then
            output_template_fields+=("$prop: if std.objectHas(output, '$prop') then output.$prop else input.value.$prop")
        else
            output_template_fields+=("['$prop']: if std.objectHas(output, '$prop') then output['$prop'] else input.value['$prop']")
        fi
    done
    output_template="{ $(join ', ' "${output_template_fields[@]}") }"

    # Create input template for updating assets, used in both inventory update and asset upsert body
    template_fields=(
        "${EXTERNAL_ID_FRAGMENT}: input.value.external_id"
    )
    if [ ! -z "$EXTERNAL_ASSET" ]; then
        template_fields+=(
            "${EXTERNAL_ASSET_FRAGMENT}: ${EXTERNAL_ASSET}"
        )
    fi
    input_template="{ $(join ', ' "${template_fields[@]}") }"

    if [ "$USE_ASSET_UPSERT" = "1" ]; then
        info "Using asset upsert for creating external ID..."
        cat "$JSON_MAP" | \
            c8y dtm assets update \
                --assetId "{id}" \
                --template "$input_template" \
                --outputTemplate "$output_template" \
                --force \
                "${C8Y_FLAGS[@]}" \
                1>> "$LOG_DIR/dtm-create-externalid-asset-update.log"
        info "Check $LOG_DIR/dtm-create-externalid-asset-update.log for details..."
    else
        info "Updating inventory to update assets..."
        cat "$JSON_MAP" | \
            c8y inventory update \
                --template "$input_template" \
                --outputTemplate "$output_template" \
                --force \
                "${C8Y_FLAGS[@]}" \
                1>> "$LOG_DIR/dtm-create-externalid-inventory-update.log"

        if [ -f "$LOG_DIR/dtm-create-externalid-inventory-update.log" ] && grep -q 'ERROR' "$LOG_DIR/dtm-create-externalid-inventory-update.log" 2>/dev/null; then
            total_failed=$((total_failed + $(grep -c 'ERROR' "$LOG_DIR/dtm-create-externalid-inventory-update.log" 2>/dev/null)))
        fi

        info "Creating identities for assets of type c8y_Asset..."
        cat "$JSON_MAP" | \
            c8y identity create \
                --type "c8y_Asset" \
                --template '{ device: input.value.id, externalId: input.value.external_id }' \
                --force \
                "${C8Y_FLAGS[@]}" \
                1>> "$LOG_DIR/dtm-create-externalid-identity.log"

        if [ -f "$LOG_DIR/dtm-create-externalid-identity.log" ] && grep -q 'ERROR' "$LOG_DIR/dtm-create-externalid-identity.log" 2>/dev/null; then
            total_failed=$(grep -c 'ERROR' "$LOG_DIR/dtm-create-externalid-identity.log" 2>/dev/null)
        fi
    fi
    
    total_processed=$(wc -l < "$JSON_MAP" | tr -d ' \n\r\t')
    end_time=$(date +%s)
    elapsed=$((end_time - start_time))

    success "Processed $total_processed assets for $C8Y_TENANT, $total_failed failed (${elapsed}s)"

    return "$total_failed"
}

# Export function and variables for parallel processing
export -f process_assets generate_external_id warn error info success
export ID_TEMPLATE EXTERNAL_ASSET EXTERNAL_ID_FRAGMENT FILTER_QUERY

# Read all assets and generate JSON map with external IDs
read_assets

# Process assets and get the return code (failure count)
process_assets