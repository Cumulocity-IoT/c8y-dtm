#!/usr/bin/env bash

# Create external IDs for DTM assets based on template with parallel processing

# Stop on unexpected errors
set -e

# Logging helper functions (output to stderr)
warn() { echo -e "\033[1;33mWARN  $*\033[0m" >&2; }
error() { echo -e "\033[1;31mERROR $*\033[0m" >&2; }
info() { echo -e "INFO  $*" >&2; }
success() { echo -e "\033[1;32mSUCCESS $*\033[0m" >&2; }

# Help text
help() {
    cat <<EOF
Create external IDs for DTM assets to be used with upserting assets.

Usage:
    c8y dtm migration externalids-create [FLAGS]

Description:
    This command creates external IDs for DTM assets using a configurable template.
    All assets or all assets matching a given query will be updated with a
    c8y_ExternalId fragment generated based on the provided template. The template
    can include placeholders for any asset fragment or property. 
    
    For the c8y_ExternalId, a external id of type c8y_Asset will be created in the
    Identity API.

Flags:
    -t, --id-template <template> Template for generating external IDs (required)
                                 Supports placeholders for any asset fragment or property
    -u, --use-asset-upsert       Use asset upsert (c8y dtm assets update) for external ID creation (default: false)
    -l, --logDir <directory>     Directory for log files (default: current directory)
    -f, --filter <query>         Query to filter assets (e.g., "type eq 'MyAssetType'", default: "not(has(${EXTERNAL_ID_FRAGMENT}))")
    -h, --help                   Show this help message
        --examples               Show usage examples

Template Placeholders:
    {<fragment>}               Any fragment (e.g., {name} or {id})
    {<fragment>.<property>}    Any fragment property (e.g., {c8y_IsDevice.name})
    
    Note: Template placeholders can reference any fragment or property available
    in the asset's JSON structure. Use dot notation for nested properties.

Requirements:
    - go-c8y-cli authenticated session (dev mode)
    - jq for JSON processing

EOF

exit 0
}

examples () {
  cat <<EOF
Examples:
    # Create external IDs with simple ID template
    c8y dtm migration externalids-create --id-template "dtm_{id}"
    
    # Use asset name and type fragments
    c8y dtm migration externalids-create --id-template "asset_{name}_{type}" --workers 8

    # Complex template with multiple fragments
    c8y dtm migration externalids-create --id-template "{owner}_{fragment.name}_{id}"

    # Check assets have properties used in template and no external IDs yet
    c8y inventory find --fragmentType "c8y_IsAsset" --select id,name,fragment1,fragment2,c8y_ExternalId --pageSize 1

    # Check identity has been created correctly
    c8y inventory find --fragmentType "c8y_IsAsset" --pageSize 1 | c8y identity list --filter 'type eq c8y_Asset' 

EOF

exit 0
}

# Default values
EXTERNAL_ID_FRAGMENT="c8y_ExternalId"

ID_TEMPLATE=""
FILTER_QUERY="not(has(${EXTERNAL_ID_FRAGMENT}))"
USE_ASSET_UPSERT=0
LOG_DIR="."
POSITIONAL_ARGS=()

# Parse Flags: --flag <value>, or boolean/switch flags: --help|-h
while [ $# -gt 0 ]; do
    case "$1" in
        # Flag which expects an argument
        -t|--id-template)
            ID_TEMPLATE="$2"
            shift
            ;;
        -f|--filter)
            FILTER_QUERY="$2"
            shift
            ;;
        -l|--logDir)
            LOG_DIR="$2"
            shift
            ;;
        -u|--use-asset-upsert)
            USE_ASSET_UPSERT=1
            ;;
        # Support showing help
        -h|--help)
            help
            ;;
        --examples)
            examples
            ;;
        # Save positional arguments
        *)
            POSITIONAL_ARGS+=("$1")
            ;;
    esac
    shift
done

# Ensure log directory exists
if [ ! -d "$LOG_DIR" ]; then
    mkdir -p "$LOG_DIR"
fi

JSON_MAP="$LOG_DIR/dtm-create-externalid-asset-map.json"

# Restore additional arguments
set -- "${POSITIONAL_ARGS[@]}"

# List of allowed global/inherited flags for c8y identity/inventory calls (short and long forms)
ALLOWED_FLAGS=(
  --debug --delay --delayBefore --header -k --insecure -l --logMessage --maxJobs --noAccept -M --noColor --noCache --progress --timeout --totalErrors --workers --verbose
)

# Parse positional args for allowed global flags
C8Y_FLAGS=()
IDX=0
while [ $IDX -lt ${#POSITIONAL_ARGS[@]} ]; do
    arg="${POSITIONAL_ARGS[$IDX]}"
    found=0
    for flag in "${ALLOWED_FLAGS[@]}"; do
        if [ "$arg" = "$flag" ]; then
            found=1
            C8Y_FLAGS+=("$arg")
            # If next arg is not another flag, treat as value
            next_idx=$((IDX+1))
            next_arg="${POSITIONAL_ARGS[$next_idx]:-}"
            if [[ ! "$next_arg" =~ ^- ]]; then
                C8Y_FLAGS+=("$next_arg")
                IDX=$((IDX+1))
            fi
            break
        fi
    done
    if [ $found -eq 0 ]; then
        error "Unknown or unsupported flag: $arg"
        exit 1
    fi
    IDX=$((IDX+1))
done

# Function to check prerequisites
check_prerequisites() {
    if ! command -v c8y >/dev/null 2>&1; then
        error "go-c8y-cli (c8y) is not installed or not in PATH"
        exit 1
    fi

    if ! command -v jq >/dev/null 2>&1; then
        error "jq is not installed or not in PATH. Please install jq for JSON processing"
        exit 1
    fi

    # Check if authenticated
    if ! c8y currentuser get >/dev/null 2>&1; then
        error "Not authenticated with Cumulocity. Please run 'set-session' first"
        exit 1
    fi
}

# Function to generate external ID from template
generate_external_id() {
    local asset_json="$1"
    local template="$2"
    local result="$template"
    local placeholders
    # Use TEMPLATE_PROPERTIES instead of extracting placeholders again
    for property_path in "${TEMPLATE_PROPERTIES[@]}"; do
        local placeholder="{$property_path}"
        jq_filter=".$property_path"

        local value=""
        # Prefer raw string values; otherwise stringify the JSON value
        value=$(echo "$asset_json" | jq -r "if ($jq_filter | type) == \"string\" then $jq_filter else ($jq_filter | tostring) end" 2>/dev/null || echo "")
        if [ "$value" = "null" ] || [ -z "$value" ]; then
            error "Missing value for property path '$property_path'"
            return 1
        fi
        result="${result//$placeholder/$value}"
    done
    echo "$result"
}

# Function to extract template properties
extract_template_properties() {
    local template="$1"
    local properties=()
    local placeholders
    placeholders=$(echo "$template" | grep -oE '\{[^}]+\}' | sort -u)
    while IFS= read -r placeholder; do
        if [ -n "$placeholder" ]; then
            # remove curly braces from placeholder
            local property_path="${placeholder//[\{\}]/}"
            properties+=("$property_path")
        fi
    done <<< "$placeholders"
    echo "${properties[@]}"
}

join() {
  local IFS="$1"
  shift
  echo "$*"
}

## Validate arguments

# Check if ID template is provided
if [ -z "$ID_TEMPLATE" ]; then
    error "ID template is required. Use --id-template option"
    exit 1
fi

# Check prerequisites
check_prerequisites

# Extract properties from template
TEMPLATE_PROPERTIES=()
for prop in $(extract_template_properties "$ID_TEMPLATE"); do
    TEMPLATE_PROPERTIES+=("$prop")
done

# Function to read assets with pagination and generate JSON lines (NDJSON)
read_assets() {
    # Initialize intermediate JSON file (clear it)
    true > "$JSON_MAP"

    local start_time end_time elapsed
    start_time=$(date +%s)

    local page_result
    local c8y_args=(inventory find --includeAll --fragmentType "c8y_IsAsset" --output json)
    if [ -n "$FILTER_QUERY" ]; then
        c8y_args+=(--query "$FILTER_QUERY")
    fi
    page_result=$(c8y "${c8y_args[@]}" 2>/dev/null)

    if [ -z "$page_result" ] || [ "$page_result" = "null" ] || [ "$page_result" = "[]" ]; then
        info "No assets found to process..."
        return 0
    fi
    
    # Build jq object with id, template properties, and external_id
    # Start with id field
    local jq_obj_fields='id: .id, self: .self'
    # Add template properties (skip 'id' if already added)
    for prop in "${TEMPLATE_PROPERTIES[@]}"; do
        if [ "$prop" != "id" ]; then
            jq_obj_fields+=", ${prop}: .${prop}"
        fi
    done
    
    # Build jq filter for external_id from template
    jq_external_id=$(echo "$ID_TEMPLATE" | sed -E 's/\{([a-zA-Z0-9_.]+)\}/\\(.\1)/g')
    
    # Add external_id field
    jq_obj_fields+=", external_id: \"$jq_external_id\""
    
    # Generate JSON lines (one JSON object per line)
    jq_filter="{$jq_obj_fields}"
    echo "$page_result" | jq -c "$jq_filter" >> "$JSON_MAP"

    duplicates=$(jq -r '.external_id' "$JSON_MAP" | sort | uniq -d)
    if [ -n "$duplicates" ]; then
        error "$duplicates" 
        error "Duplicate externalIds found. Can not create unique external IDs with the provided template."
        exit 1
    fi

    local total_collected
    total_collected=$(wc -l < "$JSON_MAP" | tr -d ' \n\r\t')
    end_time=$(date +%s)
    elapsed=$((end_time - start_time))
    success "Collected $total_collected assets for $C8Y_TENANT (${elapsed}s)"
    
    return 0
}

# Function to process assets with pagination
process_assets() {
    local total_processed=0
    local total_failed=0

    local start_time end_time elapsed
    start_time=$(date +%s)

    # Create output template for assets. This is used to capture the output of the c8y commands.
    # We include id, type, c8y_ExternalId, tenant, self, and all template properties.
    # tenant and self is added to help with debugging and tracking when running across multiple tenants.
    output_template_fields=(
        "id: if std.objectHas(output, 'id') then output.id else input.value.id"
        "type: if std.objectHas(output, 'type') then output.type else input.value.type"
        "c8y_ExternalId: if std.objectHas(output, 'c8y_ExternalId') then output.c8y_ExternalId else input.value.c8y_ExternalId"
        "['self']: if std.objectHas(output, 'self') then output['self'] else input.value['self']"
        "tenant: \"$C8Y_TENANT\""
    )

    # Add template properties, skipping duplicates and 'self'
    for prop in "${TEMPLATE_PROPERTIES[@]}"; do
        [[ "$prop" == "id" || "$prop" == "c8y_ExternalId" || "$prop" == "self" ]] && continue
        if [[ "$prop" =~ ^[a-zA-Z_][a-zA-Z0-9_]*$ ]]; then
            output_template_fields+=("$prop: if std.objectHas(output, '$prop') then output.$prop else input.value.$prop")
        else
            output_template_fields+=("['$prop']: if std.objectHas(output, '$prop') then output['$prop'] else input.value['$prop']")
        fi
    done

    output_template="{ $(join ', ' "${output_template_fields[@]}") }"

    if [ "$USE_ASSET_UPSERT" = "1" ]; then
        info "Using asset upsert (c8y dtm assets update) for external ID creation..."
        cat "$JSON_MAP" | \
            c8y dtm assets update \
                --assetId "{id}" \
                --template "{${EXTERNAL_ID_FRAGMENT}: input.value.external_id}" \
                --force \
                --outputTemplate "$output_template" \
                "${C8Y_FLAGS[@]}" \
                1>> "$LOG_DIR/dtm-create-externalid-asset-update.log"
        info "Check $LOG_DIR/dtm-create-externalid-asset-update.log for details..."
    else
        # Process in two separate steps (not piped)
        # Step 1: Update inventory with c8y_ExternalId
        info "Updating inventory with c8y_ExternalId fragment..."
        cat "$JSON_MAP" | \
            c8y inventory update \
                --template "{c8y_ExternalId: input.value.external_id}" \
                --force \
                --outputTemplate "$output_template" \
                "${C8Y_FLAGS[@]}" \
                1>> "$LOG_DIR/dtm-create-externalid-inventory-update.log"

        if [ -f "$LOG_DIR/dtm-create-externalid-inventory-update.log" ] && grep -q 'ERROR' "$LOG_DIR/dtm-create-externalid-inventory-update.log" 2>/dev/null; then
            total_failed=$((total_failed + $(grep -c 'ERROR' "$LOG_DIR/dtm-create-externalid-inventory-update.log" 2>/dev/null)))
        fi

        # Step 2: Create identity external IDs
        info "Creating identity external IDs of type c8y_Asset..."
        cat "$JSON_MAP" | \
            c8y identity create \
                --type "c8y_Asset" \
                --template '{ device: input.value.id, externalId: input.value.external_id }' \
                --force \
                "${C8Y_FLAGS[@]}" \
                1>> "$LOG_DIR/dtm-create-externalid-identity.log"

        if [ -f "$LOG_DIR/dtm-create-externalid-identity.log" ] && grep -q 'ERROR' "$LOG_DIR/dtm-create-externalid-identity.log" 2>/dev/null; then
            total_failed=$(grep -c 'ERROR' "$LOG_DIR/dtm-create-externalid-identity.log" 2>/dev/null)
        fi
    fi
    
    total_processed=$(wc -l < "$JSON_MAP" | tr -d ' \n\r\t')
    end_time=$(date +%s)
    elapsed=$((end_time - start_time))

    success "Processed $total_processed assets for $C8Y_TENANT, $total_failed failed (${elapsed}s)"

    return "$total_failed"
}

# Export function and variables for parallel processing
export -f process_assets generate_external_id warn error info success
export ID_TEMPLATE EXTERNAL_ID_FRAGMENT FILTER_QUERY

# Read all assets and generate JSON map with external IDs
read_assets

# Process assets and get the return code (failure count)
process_assets